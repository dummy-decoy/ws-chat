<!DOCTYPE html>
<html>
    <head>
        <title>chat</title>
        <style type="text/css">
            html, body {
                margin: 0;
                background-color: #aaaaaa;
            }
            #wrapper {
                display: flex;
                flex-direction: column;
                height: 100vh;
                width: 100%;
                overflow-y: hidden;
            }
            #input {
                margin: 8px;
            }
            #content {
                margin: 8px;
                flex-grow: 1;
                overflow-y: scroll;
                overflow-x: auto;
            }

            .error {
                font-weight: bold;
                color: red;
            }
            .info {
                font-weight: normal;
                color: lightslategray;
            }
            .wall {
                font-weight: normal;
                color: red;
            }
            .user {
                font-weight: bold;
                color: green;
            }
            .user.admin {
                color: yellow;
            }
            .channel {
                font-weight: bold;
                color: blue;
            }
            .topic {
                font-weight: bold;
                color: black;
            }
        </style>
        <script lang="javascript">
            function sanitize(string) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&apos;',
                    '/': '&sol;',
                    '=': '&equals;',
                    '`': '&grave;'
                };
                const reg = /[&<>"'/=`]/ig;
                return string.replace(reg, (match)=>(map[match]));
            };

            var content = undefined;
            function append(text) {
                content.innerHTML += text+'<br/>';
                content.scrollTop = content.scrollHeight;
            }
            function wall(text) {
                append('<span class="wall">'+text+'</span>');
            }
            function error(text) {
                append('<span class="error">'+text+'</span>');
            }
            function info(text) {
                append('<span class="info">'+text+'</span>');
            }
            
            function channelOptionsToString(options) {
                let result = ''
                if (options.moderated) result += 'm';
                if (options.topic) result += 't';
                if (options.secret) result += 's';
                if (options.password) result += 'k';

                if (result) return ' (+'+result+')'; else return '';
            };
            function userOptionstoString(options) {
                let plus = '';
                if (options.admin) plus += 'a';
                if (options.bot) plus += 'b';
                if (options.operator) plus += 'o';
                let minus = '';
                if (('voiced' in options) && !options.voiced) minus += 'v'

                return ' ('+(plus?'+'+plus:'')+(minus?'-'+minus:'')+')'
            };
            function channelToString(channel, options=undefined) {
                return '<span class="channel">#'+sanitize(channel)+(options?channelOptionsToString(options):'')+'</span>';
            };
            function userToString(user, options=undefined) {
                if (typeof user == 'string')
                    return '<span class="user">@'+sanitize(user)+(options?userOptionstoString(options):'')+'</span>';
                else {
                    all = {...user.options, ...options}
                    cls = !!all.admin?'admin':'';
                    prefix = !!all.bot?'!':'@';
                    return '<span class="user '+cls+'">'+prefix+sanitize(user.nick||'(undefined)')+(options?userOptionstoString(all):'')+'</span>';
                }
            };
            function identToString(user) {
                return '<span class="user">'+sanitize(user.nick||'(undefined)')+'@'+user.url+'</span>';
            };
            function stringToUser(value) {
                result = /^(?<nick>[^@#&!\s]+)(#(?<channel>[^@#&!\s]+))?(@(?<url>[^@#&!\s]*))?$/.exec(value);
                if (!result) return undefined; 
                else return result.groups;
            };

            var ws = { send: () => { error('not connected to any server</span>');} };

            function connect(host) {
                ws = new WebSocket(`ws://${host}`);
                ws.onmessage = (event) => {
                    try {
                        //append(event.data);
                        let message = JSON.parse(event.data);
                        switch (message[0]) {
                            case 'version':
                                break;
                            case 'ident':
                                wall(`you are identified as ${identToString(message[1])}`);
                                break;
                            case 'motd':
                                wall(`${sanitize(message[1].content).replace('\n','<br/>')}`);
                                break;
                            case 'time':
                                wall(`the time on the server is ${sanitize(message[1].local)}`);
                                break;
                            case 'nick':
                                if (!('old' in message[1]) || !('channel' in message[1]))
                                    append(`you are now known as ${userToString(message[1].new)}`);
                                else if ('channel' in message[1])
                                    append(`${channelToString(message[1].channel)}: ${userToString(message[1].old)} changed name to ${userToString(message[1].new)}`);
                                else
                                    append(`${userToString(message[1].old)} changed name to ${userToString(message[1].new)}`);
                                break;
                            case 'list':
                                if (message[1].channels.length)
                                    wall(`channel list:<br>&emsp;${message[1].channels.map(([channel,options])=>channelToString(channel, options)).join('<br>&emsp;')}`);
                                else
                                    wall('channel list is empty');
                                break;
                            case 'users':
                                if (message[1].channel)
                                    append(`${channelToString(message[1].channel)}: user list:<br>&emsp;${message[1].users.map(([user,options])=>userToString(user, options)+' ('+identToString(user)+')').join('<br>&emsp;')}`);
                                else
                                    wall(`user list:<br>&emsp;${message[1].users.map(([user,options])=>userToString(user, options)+' ('+identToString(user)+')').join('<br>&emsp;')}`);
                                break;
                            case 'join':
                                append(`${channelToString(message[1].channel)}: ${userToString(message[1].user)} joined the channel`);
                                break;
                            case 'topic':
                                if (message[1].value)
                                    append(`${channelToString(message[1].channel)}: topic was set to "<span class="topic">${sanitize(message[1].value)}</span>"`);
                                else
                                    append(`${channelToString(message[1].channel)}: topic was not set`);
                                break;
                            case 'msg':
                                if ('channel' in message[1])
                                    append(`${channelToString(message[1].channel)}: ${userToString(message[1].from)}: ${sanitize(message[1].content)}`);
                                else
                                    append(`${userToString(message[1].from)}: ${userToString(message[1].user)}: ${sanitize(message[1].content)}`);
                                break;
                            case 'leave':
                                append(`${channelToString(message[1].channel)}: ${userToString(message[1].user)} left the channel (${sanitize(message[1].reason||'no reason')})`);
                                break;
                            case 'mode':
                                if ('channel' in message[1]) {
                                    if ('user' in message[1]) {
                                        append(`${channelToString(message[1].channel)}: user mode for ${userToString(message[1].user)} is${userOptionstoString(message[1].options)}`);
                                    } else {
                                        append(`${channelToString(message[1].channel)}: channel mode is${channelOptionsToString(message[1].options)}`);
                                    }
                                } else if ('user' in message[1]) {
                                    wall(`user mode for ${userToString(message[1].user)} is${userOptionstoString(message[1].options)}`);
                                }
                                break;
                            case 'kick':
                                append(`${channelToString(message[1].channel)}: ${userToString(message[1].user)} was kicked out of the channel (${sanitize(message[1].reason||'no reason')})`);
                                break;
                            case 'error':
                                error(`${sanitize(message[1].message)}`);
                                break;
                        }
                    } catch (exception) {
                        error('internal error while processing server message:<br>'+exception);
                    }
                };
            };

            function help() {
                append('<span class="info">'
                    + '<p>This is ws-chat (tentative name), an IRC like chat running in your browser.</p>'
                    + '<p>command help:<table>'
                    + '<tr><td style="vertical-align:top">/help</td><td>show this help message</td></tr>'
                    + '<tr><td style="vertical-align:top">/connect&nbsp;&lt;host:port&gt;</td><td>connect to a chat server</td></tr>'
                    + '<tr><td style="vertical-align:top">/ident</td><td>ask for your own identification string</td></tr>'
                    + '<tr><td style="vertical-align:top">/motd</td><td>display the server message of the day</td></tr>'
                    + '<tr><td style="vertical-align:top">/motd&nbsp;&lt;message&gt;</td><td>set the server message of the day (requires: admin)</td></tr>'
                    + '<tr><td style="vertical-align:top">/time</td><td>show the server local time</td></tr>'
                    + '<tr><td style="vertical-align:top">/nick&nbsp;&lt;nickname&gt;</td><td>set the nickname you will be yelled at</td></tr>'
                    + '<tr><td style="vertical-align:top">/list</td><td>list all channels on this server</td></tr>'
                    + '<tr><td style="vertical-align:top">/users</td><td>list all users on the server (requires: admin)</td></tr>'
                    + '<tr><td style="vertical-align:top">/users&nbsp;&lt;#channel&gt;</td><td>list all users on the specified channel. you must have joined the channel to see the list</td></tr>'
                    + '<tr><td style="vertical-align:top">/join&nbsp;&lt;#channel&gt;&nbsp;[&lt;password&gt;]</td><td>join a channel and participate ! if the channel does not exist, it is automatically created.</td></tr>'
                    + '<tr><td style="vertical-align:top">/topic&nbsp;&lt;#channel&gt;</td><td>show the current topic of the specified channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/topic&nbsp;&lt;#channel&gt;&nbsp;&lt;topic...&gt;</td><td>set the topic of the specified channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/msg&nbsp;&lt;#channel&gt;&nbsp;&lt;message...&gt;</td><td>send a message to the specified channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/msg&nbsp;&lt;@user&gt;&nbsp;&lt;message...&gt;</td><td>send a private message to the specified user</td></tr>'
                    + '<tr><td style="vertical-align:top">/leave&nbsp;&lt;#channel&gt;&nbsp;[&lt;reason&gt;]</td><td>leave the channel. the channel is automatically destroyed when the last particiapnt leaves</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;#channel&gt;</td><td>query modes for this channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;#channel&gt;&nbsp;[+|-&nbsp;&lt;channel&nbsp;modes&gt;]&nbsp;[&lt;password&gt;]</td><td>set modes for this channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;#channel&gt;&nbsp;&lt;@user&gt;&nbsp;[+|-&nbsp;&lt;channel&nbsp;user&nbsp;modes&gt;]</td><td>set modes for this user on this channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;@user&gt;&nbsp;[+|-&nbsp;&lt;user&nbsp;modes&gt;]</td><td>set global modes for this user</td></tr>'
                    + '<tr><td style="vertical-align:top">/kick&nbsp;&lt;#channel&gt;&nbsp;&lt;@user&gt;&nbsp;[&lt;reason&gt;]</td><td>kick a user out of a channel (requires: operator, admin)</td></tr>'
                    + '<tr><td style="vertical-align:top">/select &lt;#channel&gt;</td><td>makes the specified channel the active channel. everything you type in the input box will be sent to this channel</td></tr></table>'
                    + '</p>'
                    + '<p>Differentiate users by using an extended name syntax: @nick&lt;#channel&gt;&lt;@host:port&gt;. example: @test @test#channel @test@195.52.74.10:25642 @test#channel@195.52.74.10:25642'
                    + '<p>Channel modes are:<table>'
                    + '<tr><td style="vertical-align:top">s :</td><td><i>secret</i>. the channel does not appear when listing channels with the /list command (except for server admnistrators)</td></tr>'
                    + '<tr><td style="vertical-align:top">m :</td><td><i>moderated</i>. only users with the +v mode enabled can talk to the channel</td></tr>'
                    + '<tr><td style="vertical-align:top">t :</td><td><i>limited topic</i>. only channel operators can change the topic of the channel</td></tr>'
                    + '<tr><td style="vertical-align:top">k :</td><td>  <i>password (key) protected</i>. the channel is only accessible to people knowing the password</td></tr>'
                    + '</table><br/>'
                    + '<p>Channel specific user modes are:<table>'
                    + '<tr><td style="vertical-align:top">o :</td><td><i>operator</i>. operators have super powers onto a channel</td></tr>'
                    + '<tr><td style="vertical-align:top">v :</td><td><i>voiced</i>. voiced people are allowed to talk on moderated channels</td></tr>'
                    + '</table><br/>'
                    + '<p>User modes are:<table>'
                    + '<tr><td style="vertical-align:top">a :</td><td><i>admin</i>. server administrator, better not mess with them</td></tr>'
                    + '<tr><td style="vertical-align:top">b :</td><td><i>bot</i>. complacency flag to signal a user is a bot</td></tr>'
                    + '</table></p>'
                    + '</span>')
            }

            var currentChannel = undefined;
            function input() {
                let split = (input, limit=-1) => {
                    separator = /\s+/g
                    const output = [];
                    let finalIndex = 0;
                    while (limit--) {
                        const lastIndex = separator.lastIndex;
                        const search = separator.exec(input);
                        if (search === null) {
                            break;
                        }
                        finalIndex = separator.lastIndex;
                        output.push(input.slice(lastIndex, search.index));
                    }
                    output.push(input.slice(finalIndex));
                    return output;
                }
                let send = (command, args=undefined) => {
                    data = [command];
                    if (args) data.push(args);
                    ws.send(JSON.stringify(data));
                }

                let input = document.getElementById('message');
                let command = input.value.trimEnd();
                if (command == '/help') {
                    help();
                } else if (command.startsWith('/connect ')) {
                    args = split(command, 2);
                    if (args.length > 2) error('/connect: too many arguments');
                    else connect(args[1]);
                } else if (command == '/ident') {
                    send('ident');
                } else if (command == '/motd') {
                    send('motd');
                } else if (command.startsWith('/motd ')) {
                    args = split(command, 1);
                    send('motd',{'value': args[1]});
                } else if (command == '/time') {
                    send('time');
                } else if (command.startsWith('/nick ')) {
                    args = split(command, 2);
                    if (args.length > 2) error('/nick: too many arguments');
                    else send('nick',{'new':args[1]});
                } else if (command == '/list') {
                    send('list');
                } else if (command == '/users') {
                    send('users');    
                } else if (command.startsWith('/users ')) {
                    args = split(command, 2);
                    if (args.length > 2) error('/users: too many arguments');
                    else {
                        if (!args[1].startsWith('#')) error('/users: channel expected');
                        else send('users',{'channel':args[1].slice(1)})
                    };
                } else if (command.startsWith('/join ')) {
                    args = split(command, 3);
                    if (args.length > 3) error('/join: too many arguments');
                    else {
                        if (!args[1].startsWith('#')) error('/join: channel expected');
                        else send('join',{'channel':args[1].slice(1), 'password':args.length>2?args[2]:undefined})
                    };
                } else if (command.startsWith('/topic ')) {
                    args = split(command, 2);
                    if (!args[1].startsWith('#')) error('/topic: channel expected');
                    else send('topic',{'channel':args[1].slice(1), 'value': args.length>2?args[2]:undefined})
                } else if (command.startsWith('/msg ')) {
                    args = split(command, 2);
                    if (args.length<3) error('/msg: missing the message...');
                    else {
                        if (args[1].startsWith('#')) send('msg', {'channel':args[1].slice(1), 'content':args[2]});
                        else if (args[1].startsWith('@')) {
                            let user = stringToUser(args[1].slice(1));
                            if (!user) error(`/msg: malformed user specifier ${args[1].slice(1)}`);
                            else send('msg', {'user':user, 'content':args[2]});
                        } else error('/msg: channel or user expected');
                    }
                } else if (command.startsWith('/leave ')) {
                    args = split(command, 2);
                    if (!args[1].startsWith('#')) error('/leave: channel expected');
                    else send('leave',{'channel':args[1].slice(1), 'reason': args.length>2?args[2]:undefined})
                } else if (command.startsWith('/select ')) {
                    args = split(command, 2);
                    if (args.length > 2) error('/select: too many arguments');
                    else {
                        if (!args[1].startsWith('#')) error('/select: channel expected');
                        else { 
                            currentChannel = args[1].slice(1);
                            info(`<span class="channel">#${sanitize(currentChannel)}</span> is now the active channel`);
                        }
                    };
                } else if (command.startsWith('/mode ')) {
                    args = split(command);
                    if (args[1].startsWith('#')) {
                        if ((args.length > 2) && args[2].startsWith('@')) {
                            let options = {};
                            for (let arg of args.slice(3)) {
                                let value = true;
                                for (let chr of arg) {
                                    if (chr == '+') value = true;
                                    else if (chr == '-') value = false;
                                    else if (chr == 'o') options.operator = value;
                                    else if (chr == 'v') options.voiced = value;
                                    else error('/mode: unrecognized mode character');
                                }
                            }
                            let user = stringToUser(args[2].slice(1));
                            if (!user) error(`/mode: malformed user specifier ${args[2].slice(1)}`);
                            else send('mode', {'channel':args[1].slice(1), 'user':user, 'options': args.length>3 ? options : undefined});
                        } else {
                            let options = {};
                            let password = false;
                            for (let arg of args.slice(2)) {
                                if (password) {
                                    options.password = arg;
                                    password = false;
                                } else {
                                    let value = true;
                                    for (let chr of arg) {
                                        if (chr == '+') value = true;
                                        else if (chr == '-') value = false;
                                        else if (chr == 'm') options.moderated = value;
                                        else if (chr == 's') options.secret = value;
                                        else if (chr == 't') options.topic = value;
                                        else if (chr == 'k') { password = true; }
                                        else error('/mode: unrecognized mode character');
                                    }
                                }
                            }
                            send('mode', {'channel':args[1].slice(1), 'options': args.length>2 ? options : undefined});
                        }
                    } else if (args[1].startsWith('@')) {
                        let options = {};
                        for (let arg of args.slice(2)) {
                            let value = true;
                            for (let chr of arg) {
                                if (chr == '+') value = true;
                                else if (chr == '-') value = false;
                                else if (chr == 'a') options.admin = value;
                                else if (chr == 'b') options.bot = value;
                                else error('/mode: unrecognized mode character');
                            }
                        }
                        let user = stringToUser(args[1].slice(1));
                        if (!user) error(`/mode: malformed user specifier ${args[1].slice(1)}`);
                        else send('mode', {'user': user, 'options': args.length>2 ? options : undefined});
                    } else {
                        error('no channel or user specified');
                    }
                } else if (command.startsWith('/kick ')) {
                    args = split(command, 3);
                    if (!args[1].startsWith('#')) error('/kick: channel expected before user');
                    else if (!args[2].startsWith('@')) error('/kick: user expected after channel');
                    else send('kick',{'channel':args[1].slice(1),'user':args[2].slice(1),'reason': args.length>3?args[3]:undefined});
                } else if (command.startsWith('/kill ')) {
                    args = split(command, 2);
                    if (!args[2].startsWith('@')) error('/kill: user expected after channel');
                    else send('kill', {'user':args[2].slice(1),'reason': args.length>3?args[3]:undefined});
                } else {
                    if (currentChannel) send('msg', {'channel':currentChannel, 'content':command});
                    else error('no channel selected. use /select to set the active channel.');
                }
                input.value = '';
            };

            window.onload = () => {
                content = document.getElementById('content');
                help();
            }
        </script>
    </head>
    <body>
        <div id="wrapper">
            <div id="input">
                <form action="javascript:input()">
                    <input type="text" id="message" style="width:80%" autofocus/><input type="submit" value="send"/>
                </form>
            </div>
            <div id="content"></div>
        </div>
    </body>
</html>
