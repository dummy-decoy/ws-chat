<!DOCTYPE html>
<html>
    <head>
        <title>chat</title>
        <style type="text/css">
            html, body {
                margin: 0;
                background-color: #aaaaaa;
            }
            #wrapper {
                display: flex;
                flex-direction: column;
                height: 100vh;
                width: 100%;
                overflow-y: hidden;
            }
            #input {
                margin: 8px;
            }
            #content {
                margin: 8px;
                flex-grow: 1;
                overflow-y: scroll;
                overflow-x: auto;
            }
            
            .time {
                font-weight: normal;
                font-size: x-small;
                color: lightslategray;
            }
            .error {
                font-weight: bold;
                color: red;
            }
            .info {
                font-weight: normal;
                color: lightslategray;
            }
            .wall {
                font-weight: normal;
                color: red;
            }
            
            .server {
                font-weight: bold;
                color: black;
            }
            .user {
                font-weight: bold;
                color: green;
            }
            .user.admin {
                color: yellow;
            }
            .user.self {
                color: orange;
            }
            .channel {
                font-weight: bold;
                color: blue;
            }
            .topic {
                font-weight: bold;
                color: black;
            }
        </style>
        <script src="markdown-it.min.js"></script>
        <script lang="javascript">
            function beep() {
                var snd = new Audio('data:audio/wav;base64,UklGRsIBAABXQVZFZm10IBIAAAAHAAEAQB8AAEAfAAABAAgAAABmYWN0BAAAAJABAABkYXRhkAEAALKanZudmyoaHRwcIJydm56ZuRkeGh4ZuJmdm52dIRwcHRopmp6anpl+GR4aHhqqmp2cnKEdHRsdGTiZnpqemTgZHRsdHaGcnJ2aqhoeGh4Z/5memp6aKhodHBwhnZ2bnZm4GR4aHhm4mZ2bnZ0hHBwdGiqanpqemX8ZHhoeGqqanZycoR0dGx0ZOJmemp6ZOBkdGx0doZycnZqqGh4aHhn/mZ6anpoqGh0cHCGdnZudmbgZHhoeGbiZnZudnSEcHB0aKpqemp6Z/xkeGh4aqpqdnJyhHR0bHRk4mZ6anpk4GR0bHR2hnJydmqoaHhoeGf+ZnpqemioaHRwcIZ2dm52ZuBkeGh4ZuJmdm52dIRwcHRoqmp6anpn/GR4aHhqqmp2cnKEdHRsdGTiZnpqemTgZHRsdHaGcnJ2aqhoeGh4Zf5memp6aKhodHBwhnZ2bnZm4GR4aHhm4mZ2bnZ0hHBwdGiqanpqemf4ZHhoeGqmanZycoR0dGx0ZOJmemp6ZORkeGx0coJycnZqqGx0bHRo=');
                snd.play();
            }
            
            function sanitize(string) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&apos;',
                    '/': '&sol;',
                    '=': '&equals;',
                    '`': '&grave;'
                };
                const reg = /[&<>"'/=`]/ig;
                return string.replace(reg, (match)=>(map[match]));
            };

            var content = undefined;
            var defaultAction = (command) => { error(general, 'no channel selected. use /select to set the active channel.'); };
            var myself = undefined;
            var timeFormat = Intl.DateTimeFormat(undefined, {
                hour: "numeric",
                minute: "numeric",
                hour12: false
            });
            var ws = { send: () => { error('not connected to any server</span>');} };
            var md = window.markdownit({html: false, xhtmlOut: true, breaks: true, linkify: true, typographer: false});
            
            var watchdog = undefined;
            function setWatchdog() {
                watchdog = setInterval(() => { send('ping'); }, 5*60*1000);
            }
            function clearWatchdog() {
                clearInterval(watchdog);
            }
            function resetWatchdog() {
                clearWatchdog();
                setWatchdog();
            }

            function send(command, args=undefined) {
                data = [command];
                if (args) data.push(args);
                ws.send(JSON.stringify(data));
                resetWatchdog();
            };

            function append(text) {
                content.innerHTML += '<span class="time">'+timeFormat.format(new Date())+'&ensp;</span>'+text+'<br/>';
                content.scrollTop = content.scrollHeight;
            }
            function wall(text) {
                append('<span class="wall">'+text+'</span>');
            }
            function error(text) {
                append('<span class="error">'+text+'</span>');
            }
            function info(text) {
                append('<span class="info">'+text+'</span>');
            }
            
            function channelOptionsToString(options) {
                let result = ''
                if (options.moderated) result += 'm';
                if (options.topic) result += 't';
                if (options.secret) result += 's';
                if (options.password) result += 'k';

                if (result) return ' (+'+result+')'; else return '';
            };
            function userOptionsToString(options) {
                let plus = '';
                let minus = '';
                if (options) {
                    if (options.admin) plus += 'a';
                    if (options.bot) plus += 'b';
                    if (options.operator) plus += 'o';
                        
                    if (('voiced' in options) && !options.voiced) minus += 'v'
                }
                if (!plus && !minus)
                    return '<span class="options"></span>';
                else
                    return '<span class="options">('+(plus?'+'+plus:'')+(minus?'-'+minus:'')+')</span>';
            };
            function channelToString(channel, options=undefined) {
                return '<span class="channel">#'+sanitize(channel)+(options?channelOptionsToString(options):'')+'</span>';
            };
            function userToString(user, options=undefined) {
                if (typeof user == 'string')
                    return '<span class="user">@'+sanitize(user)+'</span>'+' '+userOptionsToString(options);
                else {
                    all = {...user.options, ...options}
                    cls = !!all.admin?'admin':'';
                    prefix = !!all.bot?'!':'@';
                    return '<span class="user '+cls+'">'+prefix+sanitize(user.nick||'(undefined)')+' '+userOptionsToString(all)+'</span>';
                }
            };
            function motdToString(message) {
                return md.render(message);
            };
            function messageToString(message) {
                let msg =  md.renderInline(message);
                msg = msg.replace(/@([^@#&!\s]+)/g, (match, p1) => { 
                    let cls = 'user'; 
                    if (p1 == myself.nick) { 
                        beep(); 
                        cls += " self";
                    }; 
                    return '<span class="'+cls+'">'+match+'</span>'; 
                });
                return msg;
            };
            function identToString(user) {
                return '<span class="user">'+sanitize(user.nick||'(undefined)')+'@'+user.url+'</span>';
            };
            function patternToString(pattern) {
                return ('nick' in pattern ? pattern.nick : '*')+('channel' in pattern ? '#'+pattern.channel : '')+('url' in pattern ? '@'+pattern.url : '');
            }
            function stringToUser(value) {
                result = /^(?<nick>[^@#&!\s]+)?(#(?<channel>[^@#&!\s]+))?(@(?<url>[^@#&!\s]*))?$/.exec(value);
                if (!result) return undefined; 
                else return result.groups;
            };

            var ws = { send: () => { error('not connected to any server</span>');} };
            function selectChannel(channel) {
                let clnChannel = sanitize(channel)
                defaultAction = (command) => send('msg', {'channel':clnChannel, 'content':command});
            };
            function selectUser(user) {
                defaultAction = (command) => send('msg', {'user':user, 'content':command});
            };
            function setInputFocus() {
                document.getElementById("message").focus();
            };

            function connect(host) {
                ws = new WebSocket(`ws://${host}`);
                setWatchdog();
                ws.onmessage = (event) => {
                    try {
                        //console.log(event.data);
                        let message = JSON.parse(event.data);
                        switch (message[0]) {
                            case 'version':
                                break;
                            case 'pong':
                                break;
                            case 'ident':
                            myself = message[1];
                                wall(`you are identified as ${identToString(message[1])}`);
                                break;
                            case 'motd':
                                wall(`${messageToString(message[1].content).replace('\n','<br/>')}`);
                                break;
                            case 'time':
                                wall(`the time on the server is ${sanitize(message[1].local)}`);
                                break;
                            case 'nick':
                                if (!('old' in message[1]) || !('channel' in message[1])) {
                                    myself = message[1].new;
                                    append(`you are now known as ${userToString(message[1].new)}`);
                                } else if ('channel' in message[1]) {
                                    append(`${channelToString(message[1].channel)}: ${userToString(message[1].old)} changed name to ${userToString(message[1].new)}`);
                                } else {
                                    append(`${userToString(message[1].old)} changed name to ${userToString(message[1].new)}`);
                                }
                                break;
                            case 'list':
                                if (message[1].channels.length)
                                    wall(`channel list:<br>&emsp;${message[1].channels.map(([channel,options])=>channelToString(channel, options)).join('<br>&emsp;')}`);
                                else
                                    wall('channel list is empty');
                                break;
                            case 'users':
                                if (message[1].channel) {
                                    append(`${channelToString(message[1].channel)}: user list:<br>&emsp;${message[1].users.map(([user,options])=>userToString(user, options)+' ('+identToString(user)+')').join('<br>&emsp;')}`);
                                } else if (message[1].pattern) {
                                    wall(`users matching ${patternToString(message[1].pattern)}:<br>&emsp;${message[1].match.map(([user,options,channels])=>userToString(user, options)+' ('+identToString(user)+') '+channels.map(([channel, options])=>channelToString(channel)+userOptionsToString(options)).join(' ')).join('<br>&emsp;')}`);
                                } else {
                                    wall(`user list:<br>&emsp;${message[1].users.map(([user,options])=>userToString(user, options)+' ('+identToString(user)+')').join('<br>&emsp;')}`);
                                }
                                break;
                            case 'join':
                                append(`${channelToString(message[1].channel)}: ${userToString(message[1].user, message[1].options)} joined the channel`);
                                break;
                            case 'topic':
                                if (message[1].value)
                                    append(`${channelToString(message[1].channel)}: topic was set to "<span class="topic">${sanitize(message[1].value)}</span>"`);
                                else
                                    append(`${channelToString(message[1].channel)}: topic was not set`);
                                break;
                            case 'msg':
                                if ('channel' in message[1]) {
                                    append(`${channelToString(message[1].channel)}: ${userToString(message[1].from)}: ${messageToString(message[1].content)}`);
                                } else {
                                    if (message[1].from.url != myself.url) beep();
                                    append(`${userToString(message[1].from)}: ${userToString(message[1].user)}: ${messageToString(message[1].content)}`);
                                }
                                break;
                            case 'leave':
                                append(`${channelToString(message[1].channel)}: ${userToString(message[1].user)} left the channel (${sanitize(message[1].reason||'no reason')})`);
                                break;
                            case 'mode':
                                if ('channel' in message[1]) {
                                    if ('user' in message[1]) {
                                        append(`${channelToString(message[1].channel)}: user mode for ${userToString(message[1].user)} is ${userOptionstoString(message[1].options)||'(-)'}`);
                                    } else {
                                        append(`${channelToString(message[1].channel)}: channel mode is${channelOptionsToString(message[1].options)}`);
                                    }
                                } else if ('user' in message[1]) {
                                    wall(`user mode for ${userToString(message[1].user)} is ${userOptionstoString(message[1].options)||'(-)'}`);
                                }
                                break;
                            case 'kick':
                                append(`${channelToString(message[1].channel)}: ${userToString(message[1].user)} was kicked out of the channel (${sanitize(message[1].reason||'no reason')})`);
                                break;
                            case 'wall':
                                wall(`${userToString(message[1].from)}: ${messageToString(message[1].content)}`);
                                beep();
                                break;
                            case 'error':
                                error(`${sanitize(message[1].message)}`);
                                break;
                        }
                    } catch (exception) {
                        error('internal error while processing server message:<br>'+exception);
                    }
                };
            };

            function help() {
                append('<span class="info">'
                    + '<p>This is ws-chat (tentative name), an IRC like chat running in your browser.</p>'
                    + '<p>command help:<table>'
                    + '<tr><td style="vertical-align:top">/help</td><td>show this help message</td></tr>'
                    + '<tr><td style="vertical-align:top">/connect&nbsp;&lt;host:port&gt;</td><td>connect to a chat server</td></tr>'
                    + '<tr><td style="vertical-align:top">/ident</td><td>ask for your own identification string</td></tr>'
                    + '<tr><td style="vertical-align:top">/motd</td><td>display the server message of the day</td></tr>'
                    + '<tr><td style="vertical-align:top">/motd&nbsp;&lt;message&gt;</td><td>set the server message of the day (requires: admin)</td></tr>'
                    + '<tr><td style="vertical-align:top">/time</td><td>show the server local time</td></tr>'
                    + '<tr><td style="vertical-align:top">/nick&nbsp;&lt;nickname&gt;</td><td>set the nickname you will be yelled at</td></tr>'
                    + '<tr><td style="vertical-align:top">/list</td><td>list all channels on this server</td></tr>'
                    + '<tr><td style="vertical-align:top">/users&nbsp;&lt;pattern&gt;</td><td>list all visible users matching the specified pattern.</td></tr>'
                    + '<tr><td style="vertical-align:top">/join&nbsp;&lt;#channel&gt;&nbsp;[&lt;password&gt;]</td><td>join a channel and participate ! if the channel does not exist, it is automatically created.</td></tr>'
                    + '<tr><td style="vertical-align:top">/topic&nbsp;&lt;#channel&gt;</td><td>show the current topic of the specified channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/topic&nbsp;&lt;#channel&gt;&nbsp;&lt;topic...&gt;</td><td>set the topic of the specified channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/msg&nbsp;&lt;#channel&gt;&nbsp;&lt;message...&gt;</td><td>send a message to the specified channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/msg&nbsp;&lt;@user&gt;&nbsp;&lt;message...&gt;</td><td>send a private message to the specified user</td></tr>'
                    + '<tr><td style="vertical-align:top">/leave&nbsp;&lt;#channel&gt;&nbsp;[&lt;reason&gt;]</td><td>leave the channel. the channel is automatically destroyed when the last particiapnt leaves</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;#channel&gt;</td><td>query modes for this channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;#channel&gt;&nbsp;[+|-&nbsp;&lt;channel&nbsp;modes&gt;]&nbsp;[&lt;password&gt;]</td><td>set modes for this channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;#channel&gt;&nbsp;&lt;@users&gt;&nbsp;[+|-&nbsp;&lt;channel&nbsp;user&nbsp;modes&gt;]</td><td>set modes for all matching users on this channel</td></tr>'
                    + '<tr><td style="vertical-align:top">/mode&nbsp;&lt;@users&gt;&nbsp;[+|-&nbsp;&lt;user&nbsp;modes&gt;]</td><td>set global modes for those matching users</td></tr>'
                    + '<tr><td style="vertical-align:top">/kick&nbsp;&lt;#channel&gt;&nbsp;&lt;@users&gt;&nbsp;[&lt;reason&gt;]</td><td>kick some people out of a channel (requires: operator, admin)</td></tr>'
                    + '<tr><td style="vertical-align:top">/wall&nbsp;&lt;@users&gt;&nbsp;&lt;content&gt;</td><td>send a wall notice to all matching users (requires: admin)</td></tr>'
                    + '<tr><td style="vertical-align:top">/select &lt;#channel&gt;</td><td>makes the specified channel the active channel. everything you type in the input box will be sent to this channel</td></tr></table>'
                    + '</p>'
                    + '<p>Differentiate users by using an extended name syntax: <br/>&emsp;@nick&lt;#channel&gt;&lt;@host:port&gt;. example: @test @test#channel @test@195.52.74.10:25642 @test#channel@195.52.74.10:25642.<br/>'
                    + 'some commands (users, mode, kick, wall) accept a wildcard pattern: the command is applied to all users matching the pattern. Wildcards are * and ?, escape a wildcard by preceding it with \\.'
                    + '<p>Channel modes are:<table>'
                    + '<tr><td style="vertical-align:top">s&nbsp;:</td><td><i>secret</i>. the channel does not appear when listing channels with the /list command (except for server admnistrators)</td></tr>'
                    + '<tr><td style="vertical-align:top">m&nbsp;:</td><td><i>moderated</i>. only users with the +v mode enabled can talk to the channel</td></tr>'
                    + '<tr><td style="vertical-align:top">t&nbsp;:</td><td><i>limited topic</i>. only channel operators can change the topic of the channel</td></tr>'
                    + '<tr><td style="vertical-align:top">k&nbsp;:</td><td><i>password (key) protected</i>. the channel is only accessible to people knowing the password</td></tr>'
                    + '</table><br/>'
                    + '<p>Channel specific user modes are:<table>'
                    + '<tr><td style="vertical-align:top">o&nbsp;:</td><td><i>operator</i>. operators have super powers onto a channel</td></tr>'
                    + '<tr><td style="vertical-align:top">v&nbsp;:</td><td><i>voiced</i>. voiced people are allowed to talk on moderated channels</td></tr>'
                    + '</table><br/>'
                    + '<p>User modes are:<table>'
                    + '<tr><td style="vertical-align:top">a&nbsp;:</td><td><i>admin</i>. server administrator, better not mess with them</td></tr>'
                    + '<tr><td style="vertical-align:top">b&nbsp;:</td><td><i>bot</i>. complacency flag to signal a user is a bot</td></tr>'
                    + '</table></p>'
                    + '<p>You can use <a href="https://commonmark.org/help/" target="_blank">Markdown</a> to format messages</p>'
                    + '</span>')
            }

            function input() {
                let split = (input, limit=-1) => {
                    separator = /\s+/g
                    const output = [];
                    let finalIndex = 0;
                    while (limit--) {
                        const lastIndex = separator.lastIndex;
                        const search = separator.exec(input);
                        if (search === null) {
                            break;
                        }
                        finalIndex = separator.lastIndex;
                        output.push(input.slice(lastIndex, search.index));
                    }
                    output.push(input.slice(finalIndex));
                    return output;
                }

                let input = document.getElementById('message');
                let command = input.value.trimEnd();
                if (command == '/help') {
                    help();
                } else if (command.startsWith('/connect ')) {
                    args = split(command, 1);
                    if (args.length > 2) error('/connect: too many arguments');
                    else connect(args[1]);
                } else if (command == '/ident') {
                    send('ident');
                } else if (command == '/motd') {
                    send('motd');
                } else if (command.startsWith('/motd ')) {
                    args = split(command, 1);
                    send('motd',{'value': args[1]});
                } else if (command == '/time') {
                    send('time');
                } else if (command.startsWith('/nick ')) {
                    args = split(command, 1);
                    if (args.length > 2) error('/nick: too many arguments');
                    else send('nick',{'new':args[1]});
                } else if (command == '/list') {
                    send('list');
                } else if (command == '/users') {
                    send('users');    
                } else if (command.startsWith('/users ')) {
                    args = split(command, 1);
                    if (args.length > 2) error('/users: too many arguments');
                    else {
                        send('users',{'pattern':stringToUser(args[1])})
                    };
                } else if (command.startsWith('/join ')) {
                    args = split(command, 2);
                    if (args.length > 3) error('/join: too many arguments');
                    else {
                        if (!args[1].startsWith('#')) error('/join: channel expected');
                        else send('join',{'channel':args[1].slice(1), 'password':args.length>2?args[2]:undefined})
                    };
                } else if (command.startsWith('/topic ')) {
                    args = split(command, 2);
                    if (!args[1].startsWith('#')) error('/topic: channel expected');
                    else send('topic',{'channel':args[1].slice(1), 'value': args.length>2?args[2]:undefined})
                } else if (command.startsWith('/msg ')) {
                    args = split(command, 2);
                    if (args.length<3) error('/msg: missing the message...');
                    else {
                        if (args[1].startsWith('#')) send('msg', {'channel':args[1].slice(1), 'content':args[2]});
                        else if (args[1].startsWith('@')) {
                            let user = stringToUser(args[1].slice(1));
                            if (!user) error(`/msg: malformed user specifier ${args[1].slice(1)}`);
                            else send('msg', {'user':user, 'content':args[2]});
                        } else error('/msg: channel or user expected');
                    }
                } else if (command.startsWith('/leave ')) {
                    args = split(command, 2);
                    if (!args[1].startsWith('#')) error('/leave: channel expected');
                    else send('leave',{'channel':args[1].slice(1), 'reason': args.length>2?args[2]:undefined})
                } else if (command.startsWith('/select ')) {
                    args = split(command, 1);
                    if (args.length > 2) error('/select: too many arguments');
                    else {
                        if (!args[1].startsWith('#')) error('/select: channel expected');
                        else { 
                            let channel = sanitize(args[1].slice(1));
                            selectChannel(channel);
                            info(`${channelToString(channel)} is now the active channel`);
                        }
                    };
                } else if (command.startsWith('/mode ')) {
                    args = split(command);
                    if (args[1].startsWith('#')) {
                        if ((args.length > 2) && args[2].startsWith('@')) {
                            let options = {};
                            for (let arg of args.slice(3)) {
                                let value = true;
                                for (let chr of arg) {
                                    if (chr == '+') value = true;
                                    else if (chr == '-') value = false;
                                    else if (chr == 'o') options.operator = value;
                                    else if (chr == 'v') options.voiced = value;
                                    else error('/mode: unrecognized mode character');
                                }
                            }
                            let user = stringToUser(args[2].slice(1));
                            if (!user) error(`/mode: malformed user specifier ${args[2].slice(1)}`);
                            else send('mode', {'channel':args[1].slice(1), 'user':user, 'options': args.length>3 ? options : undefined});
                        } else {
                            let options = {};
                            let password = false;
                            for (let arg of args.slice(2)) {
                                if (password) {
                                    options.password = arg;
                                    password = false;
                                } else {
                                    let value = true;
                                    for (let chr of arg) {
                                        if (chr == '+') value = true;
                                        else if (chr == '-') value = false;
                                        else if (chr == 'm') options.moderated = value;
                                        else if (chr == 's') options.secret = value;
                                        else if (chr == 't') options.topic = value;
                                        else if (chr == 'k') { password = true; }
                                        else error('/mode: unrecognized mode character');
                                    }
                                }
                            }
                            send('mode', {'channel':args[1].slice(1), 'options': args.length>2 ? options : undefined});
                        }
                    } else if (args[1].startsWith('@')) {
                        let options = {};
                        for (let arg of args.slice(2)) {
                            let value = true;
                            for (let chr of arg) {
                                if (chr == '+') value = true;
                                else if (chr == '-') value = false;
                                else if (chr == 'a') options.admin = value;
                                else if (chr == 'b') options.bot = value;
                                else error('/mode: unrecognized mode character');
                            }
                        }
                        let user = stringToUser(args[1].slice(1));
                        if (!user) error(`/mode: malformed user specifier ${args[1].slice(1)}`);
                        else send('mode', {'user': user, 'options': args.length>2 ? options : undefined});
                    } else {
                        error('/mode: no channel or user specified');
                    }
                } else if (command.startsWith('/kick ')) {
                    args = split(command, 3);
                    if (!args[1].startsWith('#')) error('/kick: channel expected before user');
                    else if (!args[2].startsWith('@')) error('/kick: user expected after channel');
                    else send('kick',{'channel':args[1].slice(1),'user':stringToUser(args[2].slice(1)),'reason': args.length>3?args[3]:undefined});
                } else if (command.startsWith('/wall ')) {
                    args = split(command, 2);
                    if (args.length<3) error('/wall: missing the message...');
                    else if (!args[1].startsWith('@')) error('/wall: user expected after channel');
                    else send('wall',{'user':stringToUser(args[1].slice(1)),'content':args[2]});
                } else {
                    defaultAction(command);
                }
                input.value = '';
            };

            window.onload = () => {
                content = document.getElementById('content');
                help();
            }
        </script>
    </head>
    <body>
        <div id="wrapper">
            <div id="input">
                <form action="javascript:input()">
                    <input type="text" id="message" style="width:80%" autofocus/><input type="submit" value="send"/>
                </form>
            </div>
            <div id="content"></div>
        </div>
    </body>
</html>
